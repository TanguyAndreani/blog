<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2022-05-12" />
  <title>Optimiser la solution d'un challenge HackerRank - Tanguy Andreani</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="typesafe.css" />
  <link rel="stylesheet" href="pandoc.css" />
  <script src="/usr/share/javascript/mathjax/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
<a href="/blog">← index</a>

<nav id="page-nav">
    <div class="top-links">
        <a href="https://tanguyandreani.me">Portfolio</a>
        <a href="mailto:hello@tanguyandreani.me">Email</a>
        <a href="https://linkedin.com/in/tanguy-andreani-280318225">LinkedIn</a>
        <a href="https://github.com/TanguyAndreani">GitHub</a>
    </div>
</nav>


<!--<h3>Table of contents</h3>-->
<header id="title-block-header">
<h1 class="title">Optimiser la solution d’un challenge HackerRank</h1>
<p class="date">2022-05-12</p>
</header>
<!--
Points centraux:
- Avoir des exemples de code plus parlant et surtout utilisables
tout de suite (reprendre les trucs d'HackerRank).
- Bonus SQLite
- .zip/archive tar
-->
<div class="abstract">
<p>Il y a quelques jours j’ai commencé à faire des challenges sur HackerRank, notamment à la suite d’un entretien avec une boîte internationale. (Toujours en cours d’ailleurs ^^).</p>
<p>Ici, je m’intéresse à l’idée de <strong>représentation intermédiaire</strong> des données.</p>
<p>Je vais commencer par décrire les conditions de l’exercice ainsi qu’une première solution simpliste. Ensuite on va voir comment créer un algorithme plus performant en transformant un petit peu les données initiales en amont pour en faciliter le traitement en aval.</p>
</div>
<p>Cet article est un peu long comparé au sujet qu’il entend traiter. En fait, je me concentre plus sur l’explication de ma démarche que sur le problème proprement dit.</p>
<p>Je donne des exemple en NodeJS comme c’est un langage relativement générique.</p>
<h1 id="lénoncer-du-problème">L’énoncer du problème</h1>
<p>Dans ce challenge<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> (que je vous conseille de faire d’ailleurs), on commence avec deux données, un grand tableau rempli de zéros et une liste de “<em>queries</em>” (ou “<em>requêtes</em>”). Chaque requête transforme une partie du tableau.</p>
<p>Une <em>query</em> est composée de trois éléments: une position de départ, une position de fin et une valeur. Pour chaque requête, on ajoute sa valeur aux cases du tableaux qui sont entre la position de départ et la position de fin.</p>
<div class="sidenote">
<p><a href="./assets/array_manip1.png"> <img src="./assets/array_manip1.png"> </a> <span class="caption">Je me représente les requêtes comme ça. Plus une requêtes est haute plus la valeur à ajouter est élevée. L’axe des abscisses représente les indices du tableau.</span></p>
</div>
<p>Par exemple, si j’ai une requête <code>[3, 9, 7]</code> alors j’ajoute 7 à toutes les cases de 3 à 9 inclues. (Ici les indices partent de 1.)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"> * Éxecutons cette requête sur un tableau de </span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"> * 20 éléments.</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co"> */</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">let</span> tab <span class="op">=</span> <span class="kw">new</span> <span class="at">Array</span>(<span class="dv">20</span>).<span class="at">fill</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">let</span> query <span class="op">=</span> [<span class="dv">3</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">7</span>]</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">let</span> [left<span class="op">,</span> right<span class="op">,</span> value] <span class="op">=</span> query</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> left<span class="dv">-1</span><span class="op">;</span> i <span class="op">&lt;</span> right<span class="op">;</span> i<span class="op">+=</span><span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-10" title="10">    tab[i] <span class="op">+=</span> value</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="op">}</span></a></code></pre></div>
<p>L’objectif de l’exercice est d’éxecuter toutes les requêtes et de retourner le plus grand nombre du tableau après les transformations.</p>
<h1 id="première-tentative">Première tentative</h1>
<p>Ma première tentative a été de faire le calcul de la manière la plus simple possible. C’est-à-dire, pour chaque requête, d’itérer sur les cases correspondantes et d’ajouter la valeur. Exactement comme je l’ai fait au-dessus.</p>
<p>Dans le pire des cas, cet algorithme est de complexité <span class="math inline">\(O(N^2)\)</span>. En effet, pour chaque itération sur les requêtes, on fait <em>un certain nombre</em> d’itérations sur le tableau à transformer.</p>
<p>C’est cet algorithme que j’ai utilisé en premier. Il passait la plupart des tests d’HackerRank mais prenait trop de temps sur 3 ou 4 d’entre eux.</p>
<p>Il faut donc trouver un meilleur algorithme du point de vue des performances. Idéallement <span class="math inline">\(O(N)\)</span>.</p>
<h1 id="identifier-le-problème-et-chercher-une-représentation-intermédiaire">Identifier le problème et chercher une représentation intermédiaire</h1>
<p>Initialement, le tableau sur lequel on agit et la liste des requêtes sont deux entités séparées en mémoire.</p>
<p>Le tableau associe à chaque indice une valeur, et les éléments de la liste des requêtes associent à certains indices une valeur à ajouter.</p>
<p>Si on est sur une case du tableau au hasard, comment savoir quelles valeurs lui ajouter ? En cherchant toutes les requêtes qui s’appliquent à cette case ? Et ceci pour chaque case ? Toutes ces itérations peuvent certainement être évitées.</p>
<p>Peut-être faudrait-il changer l’organisation des données pour mieux les traiter ?</p>
<p>En se posant la question des <em>représentations intermédiaires</em> que l’on peut créer à partir des données à disposition et de l’énoncer de l’exercice, on peut résoudre ce problème d’efficacité.</p>
<p>Une représentation intermédiaire, c’est juste une manière de “pré-traiter”, de transformer des données afin d’en faciliter la manipulation.</p>
<p>Dans une prochaine section, on va créer cette représentation intermédiaire de manière à “embarquer” toutes les requêtes <em>dans</em> le tableau initial. L’étape finale consistera à parcourir, d’une manière ou d’une autre, ce nouveau tableau pour calculer la valeur finale de chaque case.</p>
<h1 id="parenthèse-factoriser-deux-structures-de-données">Parenthèse: “Factoriser” deux structures de données</h1>
<p>J’ai dis plus haut que les deux structures de données initiales associent des valeurs à des indices.</p>
<p>C’est un peu comme si on avait des fonctions <code>Indice -&gt; Valeur</code> (le tableau) et <code>Indice -&gt; Valeur</code> (les requêtes). Ces “fonctions” peuvent être <em>composées</em> pour en obtenir une seule, peu importe comment cela se traduit en pratique. Notons qu’ici nos fonctions ne sont pas des blocs d’instructions mais des données.</p>
<p>C’est l’objet de la prochaine section: créer une telle structure (ou fonction) et ensuite seulement, trouver un algorithme pour passer de cette structure intermédiaire à la “version finale” du tableau.</p>
<h1 id="étape-1-empaqueter-les-données-de-chaque-requêtes-dans-le-tableau">Étape 1: “Empaqueter” les données de chaque requêtes dans le tableau</h1>
<p>On veut “préparer” le tableau pour rendre le calcul final plus facile. Je rappelle que le tableau est rempli de zéros au départ.</p>
<p>Pour chaque requête, on place dans le tableau ce que j’appelerais ici des “<em>marqueurs</em>” (sans définir encore ce que c’est). Un marqueur doit, d’une manière ou d’une autre, <strong>contenir toutes les trois informations d’une requête</strong>. Je ne veux “perdre” aucune données dans le processus.</p>
<p>Mais comment définir un marqueur ?</p>
<p>D’abord, on veut que chaque marqueur contienne toutes les infos de la requête initiale (la position de départ, celle de fin, la valeur à ajouter).</p>
<p>On pourrait se dire que la meilleure manière de marquer la position dans le tableau est de placer deux marqueurs, un au début et l’autre à la fin de la requête.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/* On itère plus sur toutes les cases, juste deux. */</span></a>
<a class="sourceLine" id="cb2-2" title="2">tab[left]    <span class="op">=</span> <span class="op">?</span></a>
<a class="sourceLine" id="cb2-3" title="3">tab[right<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="op">?</span> <span class="co">// +1 parce que le marqueur se trouve après la fin.</span></a></code></pre></div>
<p>Ensuite, la meilleure manière de conserver la <em>valeur</em> d’une requête est de donner cette valeur aux deux marqueurs, plutôt qu’une valeur abritraire qui n’indiquerait rien.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1">tab[left]    <span class="op">+=</span> value</a>
<a class="sourceLine" id="cb3-2" title="2">tab[right<span class="op">+</span><span class="dv">1</span>] <span class="op">+=</span> value</a></code></pre></div>
<p>Pour éviter les pertes d’informations, j’ai choisi d’incrémenter avec <code>+=</code> plutôt que de recouvrir la case (avec <code>=</code>) au cas où d’autres requêtes n’auraient un indice en commun.</p>
<p>Notez qu’à ce moment du travail, je ne me préoccupe pas vraiment de <em>comment</em> je vais traiter mon nouveau tableau dans le détail; mais je me pose quand même des petites questions pratiques sur les informations dont je pourrais avoir besoin ensuite. <strong>C’est pour ça que certains choix semblent arbitraires, parce qu’ils le sont.</strong></p>
<p>Par contre, il y a un petit ennui.</p>
<p>Comment différencier le début d’un intervalle de sa fin, si on ajoute la même chose des deux côtés ?</p>
<div class="sidenote">
<p><a href="./assets/array_manip2.png"> <img src="./assets/array_manip2.png"> </a> <span class="caption">Représentation intermédiaire, où toutes les valeurs ont été ajoutées ou soustraites aux emplacements des requêtes. (J’ai laissé les queries pour bien montrer qu’elles se superposent aux marqueurs.)</span></p>
</div>
<p>Et si on soustrayait <code>value</code> à la fin d’une requête au lieu de l’ajouter ? Essayons.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1">tab[left]    <span class="op">+=</span>  value</a>
<a class="sourceLine" id="cb4-2" title="2">tab[right<span class="op">+</span><span class="dv">1</span>] <span class="op">+=</span> <span class="op">-</span>value</a></code></pre></div>
<p>Une fois qu’on a fait ça pour chaque query, on a un genre de <em>représentation intermédiaire</em> du tableau qu’on souhaite obtenir. <strong>Cette représentation contient tous les éléments nécessaires pour créer la représentation finale:</strong> les indices de début et de fin de chaque query, ainsi que les valeurs associées à chacune d’entre elles.</p>
<h1 id="étape-2-passer-à-la-représentation-finale">Étape 2: Passer à la représentation finale</h1>
<p>Admettons que je vous montre d’avance la “courbe” (en orange, les valeurs de chaque case du tableau) qu’on souhaite obtenir:</p>
<p><a href="./assets//array_manip3.png"><img src="./assets//array_manip3.png" /></a></p>
<p>En la superposant à la représentation intermédaire, je me dis intuitivement qu’il ne manque presque rien pour arriver à cette courbe. Visuellement, le tableau initial donné par l’énoncer contient maintenant toutes les informations qui étaient contenues dans la liste des requêtes: positions et valeurs. C’est une “bonne” représentation intermédiaire qui factorise complètement le tableau et la liste des requêtes en une seule structure.</p>
<p>Maintenant il faut réfléchir à la seconde partie de l’algorithme.</p>
<p>En testant un peu on se rend compte que la dernière opération à effectuer est l’addition, tout simplement. On obtient la représentation finale en additionnant à chaque case la case précédente dans la représentation intermédiaire.</p>
<p>En conclusion, on a eu besoin de parcourir une seule fois la liste des requêtes et une seule fois chaque case du tableau. Au cours de cette seconde itération, on peut aussi identifier la valeur maximale, ce qui est le but du challenge.</p>
<h1 id="annexe-le-code">Annexe: le code</h1>
<p>Mon implémentation finale est la suivante. J’ai fais une benchmark très archaïque avec un script Bash que vous pouvez <a href="https://ftp.cyberpunked.me/blog_files/array_manipulation.tgz">télécharger ici</a> sous forme d’archive pour tester. (Nécessite juste Node et Bash.)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// n: taille du tableau</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">// queries: liste de la forme [[8, 12, 4], [1, 100, 1], ...]</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">function</span> <span class="at">arrayManipulation</span>(n<span class="op">,</span> queries) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="co">// Remplir avec des zéros pour éviter les problèmes avec NaN.</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">let</span> arr <span class="op">=</span> <span class="kw">new</span> <span class="at">Array</span>(n).<span class="at">fill</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-6" title="6">    </a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="co">// Étape 1: représentation intermédiaire.</span></a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="cf">for</span> (<span class="kw">const</span> idx <span class="kw">in</span> queries) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-9" title="9">        <span class="kw">const</span> [left<span class="op">,</span> right<span class="op">,</span> to_add] <span class="op">=</span> queries[idx]</a>
<a class="sourceLine" id="cb5-10" title="10">        <span class="co">// Les indices donnés commencent à 1.</span></a>
<a class="sourceLine" id="cb5-11" title="11">        arr[left<span class="dv">-1</span>] <span class="op">+=</span> to_add</a>
<a class="sourceLine" id="cb5-12" title="12">        arr[right]  <span class="op">-=</span> to_add</a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="co">// Étape 2: représentation finale et recherche de la plus grande</span></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="co">// valeur.</span></a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="kw">let</span> max <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-18" title="18"></a>
<a class="sourceLine" id="cb5-19" title="19">    <span class="cf">for</span> (<span class="kw">const</span> idx <span class="kw">in</span> arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-20" title="20">        <span class="co">// La case à l&#39;indice zéro est déjà à sa valeur finale.</span></a>
<a class="sourceLine" id="cb5-21" title="21">        <span class="cf">if</span> (idx <span class="op">&gt;</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-22" title="22">            <span class="co">// Il n&#39;est pas nécessaire de sauver</span></a>
<a class="sourceLine" id="cb5-23" title="23">            <span class="co">// ces valeurs mais ça ne coûte rien ici.</span></a>
<a class="sourceLine" id="cb5-24" title="24">            arr[idx] <span class="op">+=</span> arr[idx<span class="dv">-1</span>]</a>
<a class="sourceLine" id="cb5-25" title="25">        <span class="cf">if</span> (arr[idx] <span class="op">&gt;</span> max)</a>
<a class="sourceLine" id="cb5-26" title="26">            max <span class="op">=</span> arr[idx]</a>
<a class="sourceLine" id="cb5-27" title="27">    <span class="op">}</span></a>
<a class="sourceLine" id="cb5-28" title="28"></a>
<a class="sourceLine" id="cb5-29" title="29">    <span class="cf">return</span> max</a>
<a class="sourceLine" id="cb5-30" title="30"><span class="op">}</span></a></code></pre></div>
<h1 id="bonus-petite-illustration-en-sql">Bonus: petite illustration en SQL</h1>
<details>
<p><summary>Étendre la section</summary> <!-- hello --></p>
<p>J’avais envie d’expérimenter un peu en représentant le problème à l’aide d’un moteur de base de données. (J’utilise SQLite pour que ça soit rapide à faire.)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1"><span class="ex">sqlite3</span> test.db</a></code></pre></div>
<p>Admettons que j’ai les tables suivantes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">CREATE</span> <span class="kw">TABLE</span> MY_ARRAY(</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="kw">ID</span> <span class="dt">INT</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="fu">VALUE</span> <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span></a>
<a class="sourceLine" id="cb7-4" title="4">);</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="kw">CREATE</span> <span class="kw">TABLE</span> MY_QUERIES(</a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="kw">ID</span> <span class="dt">INT</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="kw">LEFT</span> <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="kw">RIGHT</span> <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="fu">VALUE</span> <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span></a>
<a class="sourceLine" id="cb7-11" title="11">);</a></code></pre></div>
<p>Avec ces données:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_ARRAY <span class="kw">VALUES</span>(<span class="dv">0</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_ARRAY <span class="kw">VALUES</span>(<span class="dv">1</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_ARRAY <span class="kw">VALUES</span>(<span class="dv">2</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_ARRAY <span class="kw">VALUES</span>(<span class="dv">3</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_ARRAY <span class="kw">VALUES</span>(<span class="dv">4</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_ARRAY <span class="kw">VALUES</span>(<span class="dv">5</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-7" title="7"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_ARRAY <span class="kw">VALUES</span>(<span class="dv">6</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_QUERIES <span class="kw">VALUES</span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_QUERIES <span class="kw">VALUES</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb8-11" title="11"><span class="kw">INSERT</span> <span class="kw">INTO</span> MY_QUERIES <span class="kw">VALUES</span>(<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">7</span>);</a></code></pre></div>
<p>Voici une requête SQL utilisant des primitives comme <code>JOIN</code> et <code>GROUP BY</code> qui illustre ce qu’on essaye de faire:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">SELECT</span> MY_ARRAY.<span class="kw">ID</span>, <span class="fu">SUM</span>(MY_QUERIES.<span class="fu">VALUE</span>) <span class="kw">FROM</span> MY_ARRAY</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">INNER</span> <span class="kw">JOIN</span> MY_QUERIES <span class="kw">ON</span> (</a>
<a class="sourceLine" id="cb9-3" title="3">    MY_ARRAY.<span class="kw">ID</span> <span class="op">&gt;=</span> MY_QUERIES.<span class="kw">LEFT</span></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="kw">AND</span> MY_ARRAY.<span class="kw">ID</span> <span class="op">&lt;=</span> MY_QUERIES.<span class="kw">RIGHT</span></a>
<a class="sourceLine" id="cb9-5" title="5">)</a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">GROUP</span> <span class="kw">BY</span> MY_ARRAY.<span class="kw">ID</span>;</a>
<a class="sourceLine" id="cb9-7" title="7"><span class="co">-- 0|7</span></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="co">-- 1|7</span></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="co">-- 2|17</span></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="co">-- 3|21</span></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="co">-- 4|14</span></a>
<a class="sourceLine" id="cb9-12" title="12"><span class="co">-- 5|4</span></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="co">-- 6|4</span></a>
<a class="sourceLine" id="cb9-14" title="14"></a>
<a class="sourceLine" id="cb9-15" title="15"><span class="kw">SELECT</span> <span class="fu">MAX</span>(<span class="fu">VALUE</span>) <span class="kw">FROM</span> (</a>
<a class="sourceLine" id="cb9-16" title="16">    <span class="kw">SELECT</span> MY_ARRAY.<span class="kw">ID</span>, <span class="fu">SUM</span>(MY_QUERIES.<span class="fu">VALUE</span>) <span class="kw">AS</span> <span class="fu">VALUE</span> <span class="kw">FROM</span> MY_ARRAY</a>
<a class="sourceLine" id="cb9-17" title="17">    <span class="kw">INNER</span> <span class="kw">JOIN</span> MY_QUERIES <span class="kw">ON</span> (</a>
<a class="sourceLine" id="cb9-18" title="18">        MY_ARRAY.<span class="kw">ID</span> <span class="op">&gt;=</span> MY_QUERIES.<span class="kw">LEFT</span></a>
<a class="sourceLine" id="cb9-19" title="19">        <span class="kw">AND</span> MY_ARRAY.<span class="kw">ID</span> <span class="op">&lt;=</span> MY_QUERIES.<span class="kw">RIGHT</span></a>
<a class="sourceLine" id="cb9-20" title="20">    )</a>
<a class="sourceLine" id="cb9-21" title="21">    <span class="kw">GROUP</span> <span class="kw">BY</span> MY_ARRAY.<span class="kw">ID</span></a>
<a class="sourceLine" id="cb9-22" title="22">);</a>
<a class="sourceLine" id="cb9-23" title="23"><span class="co">-- 21</span></a></code></pre></div>
</details>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.hackerrank.com/challenges/crush/problem" class="uri">https://www.hackerrank.com/challenges/crush/problem</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

<footer>
    <p><i>Inspiré du blog de <a href="https://fabiensanglard.net/">Fabien Sanglard</a>.</i></p>
</footer>
</body>
</html>
